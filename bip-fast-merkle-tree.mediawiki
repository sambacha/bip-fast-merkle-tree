<pre>
  BIP: ???
  Layer: Consensus (soft fork)
  Title: Fast Merkle Trees (Consensus layer)
  Author: Mark Friedenbach <mark@friedenbach.org>
  Status: Draft
  Type: Standards Track
  Created: 2017-08-24
  License: CC-BY-SA-4.0
  License-Code: MIT
</pre>

==Abstract==

In many applications it is useful to prove membership of a data element in a set without having to reveal the entire contents of that set.
The Merkle hash tree, where inner/non-leaf nodes are labeled with the hash of the labels or values of its children, is a cryptographic tool that achieves this goal.
Bitcoin uses a Merkle hash tree construct for committing the transactions of a block into the block header.
This particular design, created by Satoshi, suffers from a serious flaw related to duplicate entries documented in the National Vulnerability Database as CVE-2012-2459[1], and also suffers from less than optimal performance due to unnecessary double-hashing.

This Bitcoin Improvement Proposal describes a more efficient Merkle hash tree construct that is not vulnerable to CVE-2012-2459 and achieves an approximate 3x decrease in hash tree construction and validation times.

==Motivation==

A Merkle hash-tree is a directed acyclic graph data structure where all non-terminal nodes are labeled with the hash of combined labels or values of the node(s) it is connected to.
Bitcoin uses a unique Merkle hash tree construct invented by Satoshi for calculating the block header commitment to the list of transactions in a block.
While it would be convenient for new applications to make use of this same data structure so as to share implementation and maintenance costs, there are three principle drawbacks to reuse.

First, Satoshi's Merkle hash-tree has a serious vulnerability[1] related to duplicate tree entries that can cause bugs in protocols that use it.
While it is possible to secure protocols and implementations against exploit of this flaw, it requires foresight and a is a bit more tricky to design secure protocols that work around this vulnerability.
Designers of new protocols ought avoid using the Satoshi Merkle hash-tree construct where at all possible in order to responsibly decrease the likelihood of downstream bugs in na√Øve implementations.

Second, Satoshi's Merkle hash-tree performs an unnecessary number of cryptographic hash function compression rounds, resulting in approximately three (3) times more computation for construction and validation than is strictly necessary.
New implementations that do not require backwards compatibility ought to consider hash-tree implementations that do not carry this unnecessary performance hit.

Third, Satoshi's algorithm presumes construction of a tree index from an ordered list, and therefore is designed to support balanced trees with a uniform path length from root to leaf for all elements in the tree.
Many applications, on the other hand, benefit from having unbalanced trees, particularly if the shorter path is more likely to be used.
While it is possible to make a few elements of a Satoshi hash-tree have shorter paths than the others, the tricks for doing so are dependent on the size of the tree and not very flexible.

Together these three reasons provide justification for specifying a standard Merkle hash-tree structure for use in new protocols that fixes these issues.
This BIP describes such a structure, and provides an example implementation.

==Specification==

A Merkle hash tree as defined by this BIP is an arbitrarily-balanced binary tree whose terminal/leaf nodes are labelled with the double-SHA256 hashes of data, whose format is outside the scope of this BIP, and interior nodes with labels constructed from the fast-SHA256 hash of its children's labels.
The following image depicts an unbalanced hash tree that will be used as an example in this specification:

[[File:https://gist.githubusercontent.com/maaku/41b0054de0731321d23e9da90ba4ee0a/raw/7d9739431c8ee5a207f37ffde34d668bfce0a8c1/unbalanced-hash-tree.png]]

'''A''', '''B''', and '''C''' are leaf labels, 32-byte double-SHA256 hashes of the data associated with the leaf.
'''Node''' and '''Root''' are interior nodes, whose labels are fast-SHA256 (defined below) hashes of their respective children's labels.
'''Node''' is labelled with the fast-SHA256 hash of the concatination of '''B''' and '''C'''.
'''Root''' is labelled with the fast-SHA256 hash of the concatination of '''A''' and '''Node''', and is the ''Merkle root'' of the tree.
Nodes with single children are not allowed.

The ''double-SHA256'' cryptographic hash function takes an arbitrary-length data as input and produces a 32-byte hash by running the data through the SHA-256 hash function as specified in FIPS 180-4[2], and then running the same hash function again on the result, as a protection against length-extension attacks.

The ''fast-SHA256'' cryptographic hash function takes two 32-byte hash values, concatenates these to produce a 64-byte buffer, and single run of the SHA-256 hash function without message paddding.
The result is a 32-byte 'midstate' which is the combined hash value and label of the interior node.
fast-SHA256 is only defined for two 32-byte inputs.

There are two special cases:
an empty Merkle tree hash a root hash value of zero,
and a Merkle tree with a single value has a root hash value equal to that double-SHA256 label.

==Rationale==

The fast-SHA256 hash function is roughly three times as fast as double-SHA256 in hash tree verification, as hashing 64 bytes of data with SHA-256 as specified by FIPS 180-4[2] takes two compression runs (because of message padding) and then a third compression run for the double-SHA256 construction.
Validating a fast-SHA256 Merkle root is therefore 3x as fast as the double-SHA256 construction used by Satoshi in bitcoin.

The application of fast-SHA256 to interior-node label updates is safe in this limited domain because the inputs are hash values and fixed in number and in length,
so the sorts of attacks prevented by message padding and double-hashing do not apply.

==Addendum: Fast Merkle Lists==

Many applications use a Merkle tree to provide indexing of, or compact membership proofs of an element in a list.
This ammendum specifies and algorithm that constructs a canonical balanced tree structure for lists of various lengths.
It differs in a subtle but important way from the algorithm used by Satoshi so as to structurally prevent the vulnerability described in [1].

# Begin with a list of arbitrary data strings.
# Pre-process the list by replacing each element with its double-SHA256 hash.
# If the list is empty, return the zero hash.
# While the list has 2 or more elements,
#* Pass through the list combining adjacent entries with the fast-SHA256 hash. If the list has an odd number of elements, leave the last element as-is (this fixes [1]). This step reduces a list of N elements to ceil(N/2) entries.
# The last remaining item in the list is the Merkle root.

This algorithm differs from Merkle lists used in bitcoin in two ways.
First, fast-SHA256 is used instead of double-SHA256 for interior node labels.
Second, final entries on an odd-length list are not duplicated and hashed, which is the mistake that led to CVE-2012-2459[1].

==References==

[1] [https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2459 National Vulnerability Database: CVE-2012-2459]

[2] [http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf Secure Hash Standard]
