<pre>
  BIP: ???
  Layer: Consensus (soft fork)
  Title: Fast Merkle Trees
  Author: Mark Friedenbach <mark@friedenbach.org>
  Status: Draft
  Type: Standards Track
  Created: 2017-08-24
  License: CC-BY-SA-4.0
  License-Code: MIT
</pre>

==Abstract==

In many applications it is useful to prove membership of a data element in a set without having to reveal the entire contents of that set.
The Merkle hash tree, where inner/non-leaf nodes are labeled with the hash of the labels or values of its children, is a cryptographic tool that achieves this goal.
Bitcoin uses a Merkle hash tree construct for committing the transactions of a block into the block header.
This particular design, created by Satoshi, suffers from a serious flaw related to duplicate entries documented in the National Vulnerability Database as CVE-2012-2459[1], and also suffers from less than optimal performance due to unnecessary double-hashing.

This Bitcoin Improvement Proposal describes a more efficient Merkle hash tree construct that is not vulnerable to CVE-2012-2459 and achieves an approximate 3x decrease in hash tree construction and validation times.

==Motivation==

A Merkle hash-tree is a directed acyclic graph data structure where all non-terminal nodes are labeled with the hash of combined labels or values of the node(s) it is connected to.
Bitcoin uses a unique Merkle hash tree construct invented by Satoshi for calculating the block header commitment to the list of transactions in a block.
While it would be convenient for new applications to make use of this same data structure so as to share implementation and maintenance costs, there are three principle drawbacks to reuse.

First, Satoshi's Merkle hash-tree has a serious vulnerability[1] related to duplicate tree entries that can cause bugs in protocols that use it.
While it is possible to secure protocols and implementations against exploit of this flaw, it requires foresight and a is a bit more tricky to design secure protocols that work around this vulnerability.
Designers of new protocols ought avoid using the Satoshi Merkle hash-tree construct where at all possible in order to responsibly decrease the likelihood of downstream bugs in na√Øve implementations.

Second, Satoshi's Merkle hash-tree performs an unnecessary number of cryptographic hash function compression rounds, resulting in approximately three (3) times more computation for construction and validation than is strictly necessary.
New implementations that do not require backwards compatibility ought to consider hash-tree implementations that do not carry this unnecessary performance hit.

Third, Satoshi's algorithm presumes construction of a tree index from an ordered list, and therefore is designed to support balanced trees with a uniform path length from root to leaf for all elements in the tree.
Many applications, on the other hand, benefit from having unbalanced trees, particularly if the shorter path is more likely to be used.
While it is possible to make a few elements of a Satoshi hash-tree have shorter paths than the others, the tricks for doing so are dependent on the size of the tree and not very flexible.

Together these three reasons provide justification for specifying a standard Merkle hash-tree structure for use in new protocols that fixes these issues.
This BIP describes such a structure, and provides an example implementation.

==Specification==

A Merkle hash tree as defined by this BIP is an arbitrarily-balanced binary tree whose terminal/leaf nodes are labelled with the double-SHA256 hashes of data, whose format is outside the scope of this BIP, and interior nodes with labels constructed from the fast-SHA256 hash of its children's labels.
The following image depicts an unbalanced hash tree that will be used as an example in this specification:

:: [[File:https://gist.githubusercontent.com/maaku/41b0054de0731321d23e9da90ba4ee0a/raw/68cedce98f10d2ce7573e121463aa3fb8c9db9c4/unbalanced-hash-tree.png]]

'''A''', '''B''', and '''C''' are leaf labels, 32-byte double-SHA256 hashes of the data associated with the leaf.
'''Node''' and '''Root''' are interior nodes, whose labels are fast-SHA256 (defined below) hashes of their respective children's labels.
'''Node''' is labelled with the fast-SHA256 hash of the concatination of '''B''' and '''C'''.
'''Root''' is labelled with the fast-SHA256 hash of the concatination of '''A''' and '''Node''', and is the ''Merkle root'' of the tree.
Nodes with single children are not allowed.

The ''double-SHA256'' cryptographic hash function takes an arbitrary-length data as input and produces a 32-byte hash by running the data through the SHA-256 hash function as specified in FIPS 180-4[2], and then running the same hash function again on the result, as a protection against length-extension attacks.

The ''fast-SHA256'' cryptographic hash function takes two 32-byte hash values, concatenates these to produce a 64-byte buffer, and single run of the SHA-256 hash function with a custom 'initialization vector' (IV) and without message paddding.
The result is a 32-byte 'midstate' which is the combined hash value and label of the interior node, with the changed IV protecting against path-length extension attacks (grinding to interpret a hash as both an inner node and a leaf).
fast-SHA256 is only defined for two 32-byte inputs.
The custom IV is the intermediate hash value generated after performing a standard SHA-256 of the following hex-encoded bytes and extracting the midstate:

    6a09e667f3bcc908 b2fb1366ea957d3e 3adec17512775099 da2f590b0667322a
    95f9060875714587 5163fcdfb907b672 1ee950bc8738f694 f0090e6c7bf44ed1

This data is the first 512 fractional bits of the square root of 2.
The resulting midstate is used as IV for the fast-SHA256 cryptographic hash function:

    static unsigned char _MidstateIV[32] =
        { 0x91, 0x06, 0x6c, 0x2b, 0x97, 0x5c, 0xc8, 0x32,
          0xe7, 0x6c, 0xd4, 0x01, 0x68, 0x21, 0x8d, 0x36,
          0x18, 0xd0, 0x9b, 0xe1, 0x9a, 0x7b, 0xff, 0xc0,
          0xec, 0x1d, 0xcc, 0xf0, 0x8f, 0x77, 0x5b, 0xbd };

As fast-SHA256 is only defined for two hash inputs, there are necessarily two special cases:
an empty Merkle tree has a root hash value of zero,
and a Merkle tree with a single value has a root hash value equal to the label of that single node (a passthrough operation with no hashing).

==Rationale==

The fast-SHA256 hash function is roughly three times as fast as double-SHA256 in hash tree verification, as hashing 64 bytes of data with SHA-256 as specified by FIPS 180-4[2] takes two compression runs (because of message padding) and then a third compression run for the double-SHA256 construction.
Validating a fast-SHA256 Merkle root is therefore 3x as fast as the double-SHA256 construction used by Satoshi in bitcoin.

The application of fast-SHA256 to interior-node label updates is safe in this limited domain because the inputs are hash values and fixed in number and in length,
so the sorts of attacks prevented by message padding and double-hashing do not apply.

The 'initialization vector' for fast-SHA256 is changed in order to prevent the possible attack of grinding a hash value that can serve both as a leaf hash and as an inner node commitment to another leaf hash.
The IV is computed using standard SHA-256 plus midstate extraction so as to preserve compatability with cryptographic library interfaces that do not support custom IVs, at the cost of a 2x performance hit in that case.
The data to be hashed data is a nothing-up-my-sleeve number that is unlikely to have a known hash preimage.

The Merkle root hash of a single element tree is a simple pass-through of the leaf hash without modification so as to allow for chained validation of split proofs.
This is particularly useful when the validation environment constrains proof sizes, such as push limits in Bitcoin script.
Chained validation allows a verifier to split one proof into two or more, where the leaf is shown to be under an inner node, and that inner node is shown to be under the root.
Without pass-through hashing in a single-element tree, use of chained validation would unnecessarily introduce a minimum path length requirement equal to the number of chain links.
Pass-through hashing of single elements allows instead for one or more of the chained validations to use a "NOP" proof consisting of a zero-length path, thereby allowing, for example, a series of 4 chained validations to verify a length 3 path.

==Inclusion Proofs==

An important use of Merkle hash trees is the ability to compactly prove membership with log-sized proofs.
This section specifies a standard encoding for a single-element inclusion proof.

To prove that a hash is contained within a Merkle tree with a given root requires four pieces of information:

# The root hash of the Merkle tree;
# The hash of the node under consideration, usually the double-SHA256 of a data element, but potentially the label of an interior node instead;
# The path from the root to the node under consideration, expressed as a series of left/right binary choices; and
# The hash values of branches not taken along the path.

Typically the last two elements, the path and the elided branch hashes, are lumped together and referred to as the ''proof''.

The path is represented as an unsigned integer with a number of bits equal to the length of the path.
A zero (0) indicates the left-branch is taken and the elided right-branch hash is provided, while a one (1) indicates a right-branch is taken and the elided left-branch hash is provided.
The list of hashes for branches not taken is equal in size to the length of the path.
The following algorithm validates a proof:

# Begin with a root hash '''r''', a leaf hash '''v''', an integer path '''p''', and a list of branch hashes '''b'''.
# Set '''h''' to the leaf value '''v'''.
# For i in <nowiki>[0, path length):</nowiki>
#* If <nowiki>p&(1<<i) [bit i is set in p]: h = fast-SHA256(b[i] || h)</nowiki>
#* Else <nowiki>[bit i is not set in p]: h = fast-SHA256(h || b[i])</nowiki>
# Check if '''h''' matches the root hash '''r'''.

Note what this algorithm implies: lower-order path bits are closer to the element being proved, whereas higher-order path bits are closer to the root, and branch hashes are stored from bottom (sibling to the element) to top (child of the root).

A proof is serialized by first serializing the path as a variable-length unsigned integer, using the VARINT serialization format, then the hashes are serialized from bottom to top.
This serialization format implicitly encodes the length of the proof as the number of 32-byte hashes which can be extracted from the stream after the path has been deserialized.
To prevent proof malleability, a path cannot have a bit set for which there is no corresponding branch hash, and such proofs should fail validation.

Note that this serialization format is not self-segmenting.
The deserializer must know how long the proof object is to determine how many hashes to read.

==Fast Merkle Lists==

Many applications use a Merkle tree to provide indexing of, or compact membership proofs of an element in a list.
This ammendum specifies an algorithm that constructs a canonical balanced tree structure for lists of various lengths.
It differs in a subtle but important way from the algorithm used by Satoshi so as to structurally prevent the vulnerability described in [1].

# Begin with a list of arbitrary data strings.
# Pre-process the list by replacing each element with its double-SHA256 hash.
# If the list is empty, return the zero hash.
# While the list has 2 or more elements,
#* Pass through the list combining adjacent entries with the fast-SHA256 hash. If the list has an odd number of elements, leave the last element as-is (this fixes [1]). This step reduces a list of N elements to ceil(N/2) entries.
# The last remaining item in the list is the Merkle root.

This algorithm differs from Merkle lists used in bitcoin in two ways.
First, fast-SHA256 is used instead of double-SHA256 for interior node labels.
Second, final entries on an odd-length list are not duplicated and hashed, which is the mistake that led to CVE-2012-2459[1].

==Implementation==

An implementation of this BIP for extraction of Merkle branches and fast Merkle branch validation is available at the following Github repository:

[https://github.com/maaku/bitcoin/tree/fast-merkle-tree]

Also included in this repo is a 'merklebranch' RPC for calculating root values and extracting inclusion proofs for both arbitrary trees and trees constructed from lists of values using the algorithm in this BIP.

==References==

[1] [https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2459 National Vulnerability Database: CVE-2012-2459]

[2] [http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf Secure Hash Standard]
