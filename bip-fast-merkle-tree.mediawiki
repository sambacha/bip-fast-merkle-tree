<pre>
  BIP: ???
  Layer: Consensus (soft fork)
  Title: Fast Merkle Trees (Consensus layer)
  Author: Mark Friedenbach <mark@friedenbach.org>
  Status: Draft
  Type: Standards Track
  Created: 2017-08-24
  License: CC-BY-SA-4.0
  License-Code: MIT
</pre>

==Abstract==

In many applications it is useful to prove membership of a data element in a set without having to reveal the entire contents of that set.
The Merkle hash tree, where inner/non-leaf nodes are labeled with the hash of the labels or values of its children, is a cryptographic tool that achieves this goal.
Bitcoin uses a Merkle hash tree construct for committing the transactions of a block into the block header.
This particular design, created by Satoshi, suffers from a serious flaw related to duplicate entries documented in the National Vulnerability Database as CVE-2012-2459[1], and also suffers from less than optimal performance due to unnecessary double-hashing.

This Bitcoin Improvement Proposal describes a more efficient Merkle hash tree construct that is not vulnerable to CVE-2012-2459 and achieves an approximate 3x decrease in hash tree construction and validation times.

==Motivation==

A Merkle hash-tree is a directed acyclic graph data structure where all non-terminal nodes are labeled with the hash of combined labels or values of the node(s) it is connected to.
Bitcoin uses a unique Merkle hash tree construct invented by Satoshi for calculating the block header commitment to the list of transactions in a block.
While it would be convenient for new applications to make use of this same data structure so as to share implementation and maintenance costs, there are three principle drawbacks to reuse.

First, Satoshi's Merkle hash-tree has a serious vulnerability[1] related to duplicate tree entries that can cause bugs in protocols that use it.
While it is possible to secure protocols and implementations against exploit of this flaw, it requires foresight and a is a bit more tricky to design secure protocols that work around this vulnerability.
Designers of new protocols ought avoid using the Satoshi Merkle hash-tree construct where at all possible in order to responsibly decrease the likelihood of downstream bugs in na√Øve implementations.

Second, Satoshi's Merkle hash-tree performs an unnecessary number of cryptographic hash function compression rounds, resulting in approximately three (3) times more computation for construction and validation than is strictly necessary.
New implementations that do not require backwards compatibility ought to consider hash-tree implementations that do not carry this unnecessary performance hit.

Third, Satoshi's algorithm presumes construction of a tree index from an ordered list, and therefore is designed to support balanced trees with a uniform path length from root to leaf for all elements in the tree.
Many applications, on the other hand, benefit from having unbalanced trees, particularly if the shorter path is more likely to be used.
While it is possible to make a few elements of a Satoshi hash-tree have shorter paths than the others, the tricks for doing so are dependent on the size of the tree and not very flexible.

Together these three reasons provide justification for specifying a standard Merkle hash-tree structure for use in new protocols that fixes these issues.
This BIP describes such a structure, and provides an example implementation.

==Specification==

A Merkle hash tree as defined by this BIP is an arbitrarily-balanced binary tree whose terminal/leaf nodes are labelled with the double-SHA256 hashes of data, whose format is outside the scope of this BIP, and interior nodes with labels constructed from the fast-SHA256 hash of its children's labels.
The following image depicts an unbalanced hash tree that will be used as an example in this specification:

<img src="unbalanced-hash-tree.png">

'''A''', '''B''', and '''C''' are leaf labels, 32-byte double-SHA256 hashes of the data associated with the leaf.
'''Node''' and '''Root''' are interior nodes, whose labels are fast-SHA256 (defined below) hashes of their respective children's labels.
'''Node''' is labelled with the fast-SHA256 hash of the concatination of '''B''' and '''C'''.
'''Root''' is labelled with the fast-SHA256 hash of the concatination of '''A''' and '''Node''', and is the ''Merkle root'' of the tree.
Nodes with single children are not allowed.

The ''double-SHA256'' cryptographic hash function takes an arbitrary-length data as input and produces a 32-byte hash by running the data through the SHA-256 hash function as specified in FIPS 180-4[2], and then running the same hash function again on the result, as a protection against length-extension attacks.

The ''fast-SHA256'' cryptographic hash function takes two 32-byte hash values, concatenates these to produce a 64-byte buffer, and single run of the SHA-256 hash function without message paddding.
The result is a 32-byte 'midstate' which is the combined hash value and label of the interior node.
fast-SHA256 is only defined for two 32-byte inputs.

There are two special cases:
an empty Merkle tree hash a root hash value of zero,
and a Merkle tree with a single value has a root hash value equal to that double-SHA256 label.

==References==

[1] [https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2459 National Vulnerability Database: CVE-2012-2459]
[2] [http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf Secure Hash Standard]
